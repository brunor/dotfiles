

:set prompt "\ESC[1;34mÎ»> \ESC[m"

--:def hoogle \str -> return $ ":! hoogle --count=15 \"" ++ str ++ "\""

-- <http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/dot-squashed.ghci641>
let { redir varcmd = case break Data.Char.isSpace varcmd of { (var,_:cmd) -> return $ unlines [":set -fno-print-bind-result","tmp <- System.Directory.getTemporaryDirectory","(f,h) <- System.IO.openTempFile tmp \"ghci\"","sto <- GHC.Handle.hDuplicate System.IO.stdout","GHC.Handle.hDuplicateTo h System.IO.stdout","System.IO.hClose h",cmd,"GHC.Handle.hDuplicateTo sto System.IO.stdout","let readFileNow f = readFile f >>= \\t->length t `seq` return t",var++" <- readFileNow f","System.Directory.removeFile f"]; _ -> return "putStrLn \"usage: :redir <var> <cmd>\"" } }
:def redir redir
-- End copied material

-- Integration with the hlint code style tool
let hlint _ = return $ unlines [":set -w",    ":redir hlintvar1 :show modules", ":cmd return (\":! hlint \" ++ (concat $ Data.List.intersperse \" \" (map (fst . break (==',') . drop 2 . snd . break (== '(')) $ lines hlintvar1)))",    ":set -Wall"]
:def hlint hlint

:m - Prelude
:m + GOA
setLambdabotHome "/home/bruno/.cabal/bin"
:def bs        lambdabot "botsnack"
:def pl        lambdabot "pl"
:def unpl      lambdabot "unpl"
:def redo      lambdabot "redo"
:def undo      lambdabot "undo"
:def index     lambdabot "index"
:def docs      lambdabot "docs"
:def instances lambdabot "instances"
-- :def hoogle    lambdabot "hoogle"
:def source    lambdabot "fptools"
:def where     lambdabot "where"
:def version   lambdabot "version"
:def src       lambdabot "src"